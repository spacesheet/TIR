[%hardbreaks]
3.1 사용자 식별
'id'@'127.0.0.1'
'id'@'%'
% : 모든 외부 컴퓨터에서 접속 가능한 계정 생성

[%hardbreaks]
3.2 사용자 계정 관리
3.2.1 시스템 계정과 일반 계정
- 계정 관리
- 다른 세션 또는 그 세션에서 실행 중인 쿼리를 강제 종료
- 스토어드 프로그램 생성 시 DEFINER를 타 사용자로 설정

- 'mysql.sys'@'localhost': 기본으로 내장된 sys 스키마의 객체들의 DEFINER로 사용되는 계정
- 'mysql.session'@'localhost': MySQL 플러그인이 서버로 접근할 때 사용되는 계정
- 'mysql.infoschema'@'localhost': information_schema에 정의된 뷰의 DEFINER로 사용되는 계정

[%hardbreaks]
3.2.2 계정 생성
* 계정의 인증 방식과 비밀번호
* 비밀번호 관련 옵션
* 기본 역할
* SSL 옵션
* 계정 잠금 여부

[%hardbreaks]
3.3 비밀번호 관리
validate_password 시스템 변수 확인 가능

[%hardbreaks]
3.4 권한
- 글로벌 권한: 데이터베이스나 테이블 이외의 객체에 적용되는 권한 // 특정 객체 명시 필요
- 객체 권한: 데이터베이스나 테이블을 제어하는 데 필요한 권한 // 특정 객체 명시X

[%hardbreaks]
3.5 역할


[%hardbreaks]
4.1 MySQL 엔진 아키텍처
4.1.1 MySQL의 전체구조
MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분
4.1.2.1 포그라운드 스레드(클라이언트 스레드)
4.1.2.2 백그라운드 스레드
로그 스레드와 쓰기 스레드
4.1.3 메모리 할당 및 사용 구조
4.1.3.1글로벌 메모리 영역
모든 스레드에 공유 됨
4.1.3.2로컬 메모리 영역
세션 메모리 영역
커넥션 버퍼와 정렬(소트) 버퍼
각 클라이언트 스레드별로 독립적으로 할당되며, 절대 공유되어 사용되지 않음
4.1.4 플러그인 스토리지 엔진 모델
플러그인 모델
플러그인끼리 통신 불가
서버의 변수나 함수를 직접 호출하기에 안전하지 않음(캡슐화 안 됨)
상호 의존 관계 설정 불가로 초기화 어려움
4.1.5 컴포넌트
컴포넌트 아키텍처
4.1.6 쿼리 실행 구조
4.1.6.1 쿼리 파서
쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
4.1.6.2 전처리기
파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는 지 확인
4.1.6.3 옵티마이저
사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정 (두뇌)
4.1.6.4 실행 엔진
손과 발
만들어진 계획대로 각 핸들러에게서 받은 요청 결과를 다른 핸들러의 요청 입력으로 연결
4.1.6.5 핸들러(스토리지 엔진)
손과 발
MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따른 뎅이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할
4.1.7 복제
4.1.8 쿼리 캐시
SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실헹되면 테이블을 읽지 않고 즉시 결과를 반환
4.1.9 스레드 풀
내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
불필요한 컨텍스트 스위치를 줄여서 오버헤드를 낮춤
Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리
4.1.10 트랜잭션 지원 메타데이터
테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 함
파일로 저장하다가 8.0에 InnoDB의 테이블에 저장하도록 개선됨. 시스템 테이블
스키마 변경 작업 중간에 비정상적으로 종료되면 스키마 변경이 완전한 성공 또는 실패로 정리됨
4.2 InnoDB 스토리지 엔진 아키텍처
레코드 기반의 잠금 제공, 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남
4.2.1 프라이머리 키에 의한 클러스터링
프라이머리 키를 기준으로 클러스터링되어 저장(프라이머리 키 값의 순서대로 디스크에 저장 됨)
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키 값을 논리적인 주소로 사용
프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리 됨
4.2.2 외래 키 지원
4.2.3 MVCC(Multi Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원
잠금을 사용하지 않는 일관된 읽기 제공
InnoDB는 언두로그를 이용해 구연
멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨
격리 수준에 따라 테이블의 데이터 변경 처리가 달라짐
4.2.4 잠금 없는 일관된 읽기
4.2.5 자동 데드락 감지
잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리
데드락 감지 스레드가 교착 상태에 빠진 트랜잭션들을 찾아서 언두 로그 양에 따라 그중 하나를 강제 종료
4.2.6 자동화된 장애 복구
데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 함
4.2.7 InnoDB 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 잇게 해주는 버퍼 역할
변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있음
4.2.7.2 버퍼 풀의 구조
버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
LRU 리스트, 플러시 리스트, 프리 리스트로 관리한다.
프리 리스트: 비어 있는 페이지들의 목록. 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
LRU 리스트: LRU(Old 서브리스트)와 MRU(New 서브리스트)의 리스트가 결합된 형태
디스크로부터 한 번 읽ㅇ어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것
플러시 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. 그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않음
체크포인트를 발생시켜 동기화.
체크포인트는 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할
4.2.7.3 버퍼 풀과 리두 로그
InnoDB 버퍼 풀의 용도는 데이터 캐시와 쓰기 버퍼링가 있음
*리두 로그의 전체 구조
실제 쓰기 버퍼링(리두 로그 크기)
최대 허용 가능한 더티 페이지(버퍼 풀)
4.2.7.4 버퍼 풀 플러시
4.2.7.4.1 플러시 리스트 플러시
플러시 리스트 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업 수행
언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리됨
클리너 스레드: 더티 페이지를 디스크로 동기화하는 스레드
하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하도록 함
innodb_max_dirty_pages_pct_lwm 변수: 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크에 기록하는 역할
어댑티브 플러시: 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기 실행
innodb_flush_neighbors: 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중에서 더티 페이지가 있따면 InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해주는 기능
4.2.7.4.2 LRU 리스트 플러시
사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만듦
4.2.7.5 버퍼 풀 상태 백업 및 복구
워밍업: 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태
InnoDB 엔진은 MySQL 서버가 셧다운 되기 전에 버퍼 풀의 백업을 실행하고, MySQL 서버가 시작되면 자동으로 백업된 버퍼 풀의 상태를 복구할 수 있는 기능 제공
4.2.7.6 버퍼 풀의 적재 내용 확인
innodb_cached_indexes 테이블: 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능
4.2.8 Double Write Buffer
페이지가 일부만 기록되는 현상을 파셜 페이지 또는 톤 페이지라고 함
하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생 가능한데,
InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 A~E까지의 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다.
그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나식 랜덤으로 쓰기를 실행한다.
데이터의 안정성을 위해 사용. 데이터 무결성이 중요하면 활성화 고려.
4.2.9 언두 로그
MVCC를 InnoDB에 구현한 것
트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업하는데 이렇게 백업된 데이터
4.2.9.1 언두 로그 모니터링
트랜잭션의 롤백 대비용
트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공
4.2.9.2 언두 테이블스페이스 관리
최대 동시 트랜잭션 수 = InnoDB vpdlwl zmrl / 16 * 롤백 세그먼트 개수 * 언두 테이블스페이스 개수
4.2.10 체인지 버퍼
임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키는데 이때 사용하는 임시 메모리 공간
버퍼 머지 스레드: 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데 이 스레드
4.2.11 리두 로그 및 로그 버퍼
리두 로그는 영속성과 관련
서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
4.2.11.1 리두 로그 아카이빙
데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해줌
4.2.11.2 리두 로그 활성화 및 비활성화
4.2.12 어댑티브 해시 인덱스
인덱스: 테이블에 사용자가 생성해둔 B-Tree 인덱스
사용자가 수동으로 생성하는 인덱스가 아니라, InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
내부 잠금(세마 포어) 경합을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능 제공
4.4 MySQL 로그 파일
MySQL의 상태나 부하를 일으키는 원인을 찾아 해결
4.4.1 에러 로그 파일
실행 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일
제너럴 쿼리 로그
슬로우 쿼리 로그

